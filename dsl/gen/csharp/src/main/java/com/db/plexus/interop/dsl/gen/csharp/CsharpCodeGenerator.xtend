/**
 * Copyright 2017 Plexus Interop Deutsche Bank AG
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.db.plexus.interop.dsl.gen.csharp

import com.db.plexus.interop.dsl.gen.PlexusGenConfig
import com.db.plexus.interop.dsl.protobuf.Message
import com.db.plexus.interop.dsl.protobuf.Method
import com.db.plexus.interop.dsl.protobuf.Option
import com.db.plexus.interop.dsl.protobuf.Proto
import com.db.plexus.interop.dsl.protobuf.Service
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.resource.XtextResource

import static extension com.db.plexus.interop.dsl.gen.InteropLangUtils.*
import com.db.plexus.interop.dsl.Application
import com.db.plexus.interop.dsl.ProvidedService
import org.eclipse.emf.common.util.URI
import com.db.plexus.interop.dsl.ConsumedService

class CsharpCodeGenerator  {
    
    IQualifiedNameProvider qualifiedNameProvider    
    PlexusGenConfig config    
    URI baseDirUri
    String accessModifier
      
    new(PlexusGenConfig config, IQualifiedNameProvider qualifiedNameProvider, URI baseDirUri, String accessModifier) {
    	this.accessModifier = accessModifier;    	
    	this.config = config
    	this.qualifiedNameProvider = qualifiedNameProvider
    	this.baseDirUri = baseDirUri
    }
    
    def String gen(XtextResource resource) {
		'''		
			// <auto-generated>
			// 	Generated by the Plexus Interop compiler.  DO NOT EDIT!
			// 	source: «resource.URI.deresolve(baseDirUri).toFileString»
			// </auto-generated>
			#pragma warning disable 1591, 0612, 3021
			#region Designer generated code
			namespace «resource.csharpNamespace» {
				
				using System;
				using global::Plexus;
				using global::Plexus.Channels;
				using global::Plexus.Interop;
				using global::System.Threading.Tasks;
								
				«FOR service : resource.services SEPARATOR '\n'»
					«gen(service)»
				«ENDFOR»
								
				«FOR application : resource.applications SEPARATOR '\n'»
					«gen(application)»
				«ENDFOR»
			}
			#endregion Designer generated code
		'''
	}
	
	def String gen(Application application) {
		'''
			«accessModifier» sealed partial class «application.name.toFirstUpper»: ClientBase {
				
				public const string Id = "«getFullName(application, qualifiedNameProvider)»";
				
				«IF application.providedServices.length > 0»				
				private static ClientOptions CreateClientOptions(«application.name.toFirstUpper».ServiceBinder serviceBinder, Func<ClientOptionsBuilder, ClientOptionsBuilder> setup = null) {
					ClientOptionsBuilder builder = new ClientOptionsBuilder().WithApplicationId(Id).WithDefaultConfiguration();
					serviceBinder.Bind(builder);
					if (setup != null) {
						builder = setup(builder);
					}
					return builder.Build();
				}
				
				public «application.name.toFirstUpper»(
					«FOR providedService: application.providedServices»
						«providedService.aliasOrName»Binder «providedService.aliasOrName.toFirstLower»Binder,
					«ENDFOR»
					Func<ClientOptionsBuilder, ClientOptionsBuilder> setup = null
				)
				:this(new «application.name.toFirstUpper».ServiceBinder(
					«FOR providedService: application.providedServices SEPARATOR ','»
						«providedService.aliasOrName.toFirstLower»Binder
					«ENDFOR»					
				), setup) { }
				
				public «application.name.toFirstUpper»(«application.name.toFirstUpper».ServiceBinder serviceBinder, Func<ClientOptionsBuilder, ClientOptionsBuilder> setup = null): base(CreateClientOptions(serviceBinder, setup)) 
				{
					«FOR consumedService : application.consumedServices»
					«consumedService.aliasOrName» = new «application.name.toFirstUpper».«consumedService.aliasOrName»Proxy(this);
					«ENDFOR»
				}
				
				public sealed partial class ServiceBinder {
														
					public ServiceBinder(					
						«FOR providedService: application.providedServices SEPARATOR ','»
							«providedService.aliasOrName»Binder «providedService.aliasOrName.toFirstLower»Binder
						«ENDFOR»
					) {
						«FOR providedService: application.providedServices SEPARATOR ','»
							«providedService.aliasOrName»Binder = «providedService.aliasOrName.toFirstLower»Binder;
						«ENDFOR»
					}
					
					«FOR providedService: application.providedServices»
						public «providedService.aliasOrName»Binder «providedService.aliasOrName»Binder { get; private set; }
					«ENDFOR»
					
					public ClientOptionsBuilder Bind(ClientOptionsBuilder builder) {
						«FOR providedService: application.providedServices»
							builder = «providedService.aliasOrName»Binder.Bind(builder);
						«ENDFOR»
						return builder;
					}
				}				
				
				«FOR providedService: application.providedServices SEPARATOR '\n'»
					public partial interface I«providedService.aliasOrName»Impl«IF providedService.methods.length > 0»:«ENDIF»
						«FOR providedMethod : providedService.methods SEPARATOR ','»
							«providedService.service.csharpFullName».I«providedMethod.method.name.toFirstUpper»Impl
						«ENDFOR»
					{ }
					
					public sealed partial class «providedService.aliasOrName»Binder {
						
						public static «providedService.aliasOrName»Binder Create(I«providedService.aliasOrName»Impl impl) {
							return new «providedService.aliasOrName»Binder(impl);
						}
						
						public static «providedService.aliasOrName»Binder Create<T>(T impl)
							«IF providedService.methods.length > 0»
								where T:
								«FOR providedMethod : providedService.methods SEPARATOR ','»
									«providedService.service.csharpFullName».I«providedMethod.method.name.toFirstUpper»Impl
								«ENDFOR»
							«ENDIF»
						{
							return Create((I«providedService.aliasOrName»Impl)new «providedService.aliasOrName»Impl<T>(impl));
						}
						
						private readonly I«providedService.aliasOrName»Impl _impl;
						
						private «providedService.aliasOrName»Binder(I«providedService.aliasOrName»Impl impl) {
							_impl = impl;
						}
						
						public ClientOptionsBuilder Bind(ClientOptionsBuilder builder) {
							«IF providedService.alias === null»
							return builder.WithProvidedService("«getFullName(providedService.service, qualifiedNameProvider)»", Bind);
							«ELSE»
							return builder.WithProvidedService("«getFullName(providedService.service, qualifiedNameProvider)»", "«providedService.alias»", Bind);
							«ENDIF»							
						}
						
						private ProvidedServiceDefinition.Builder Bind(ProvidedServiceDefinition.Builder builder) {
							«FOR providedMethod : providedService.methods»
								«IF providedMethod.method.isPointToPoint»
								builder = builder.WithUnaryMethod«providedMethod.method.genericArgs»(«providedMethod.method.service.getCsharpFullName()».«providedMethod.method.name.toFirstUpper»MethodId, _impl.«providedMethod.method.name.toFirstUpper»);
								«ELSEIF providedMethod.method.serverStreaming»
								builder = builder.WithServerStreamingMethod«providedMethod.method.genericArgs»(«providedMethod.method.service.getCsharpFullName()».«providedMethod.method.name.toFirstUpper»MethodId, _impl.«providedMethod.method.name.toFirstUpper»);
								«ELSEIF providedMethod.method.clientStreaming»
								builder = builder.WithClientStreamingMethod«providedMethod.method.genericArgs»(«providedMethod.method.service.getCsharpFullName()».«providedMethod.method.name.toFirstUpper»MethodId, _impl.«providedMethod.method.name.toFirstUpper»);
								«ELSEIF providedMethod.method.bidiStreaming»
								builder = builder.WithDuplexStreamingMethod«providedMethod.method.genericArgs»(«providedMethod.method.service.getCsharpFullName()».«providedMethod.method.name.toFirstUpper»MethodId, _impl.«providedMethod.method.name.toFirstUpper»);
								«ENDIF»														
							«ENDFOR»
							return builder; 							
						}
					}
					
					public sealed partial class «providedService.aliasOrName»Impl<T>: I«providedService.aliasOrName»Impl
						«IF providedService.methods.length > 0»
							where T:
							«FOR providedMethod : providedService.methods SEPARATOR ','»
								«providedService.service.csharpFullName».I«providedMethod.method.name.toFirstUpper»Impl
							«ENDFOR»
						«ENDIF» 
					{
						private readonly T _impl;
						
						public «providedService.aliasOrName»Impl(T impl) {
							_impl = impl;
						}
						
						«FOR providedMethod : providedService.methods SEPARATOR '\n'»
							public «genImplSignature(providedMethod.method)» {
								return «genImplCallCode(providedMethod.method, "_impl")»;
							}
						«ENDFOR»						
					}
				«ENDFOR»
				«ELSE»
					private static ClientOptions CreateClientOptions(Func<ClientOptionsBuilder, ClientOptionsBuilder> setup = null) {
						ClientOptionsBuilder builder = new ClientOptionsBuilder().WithApplicationId(Id).WithDefaultConfiguration();
						if (setup != null) {
							builder = setup(builder);
						}									
						return builder.Build();					
					}
					
					public «application.name.toFirstUpper»(Func<ClientOptionsBuilder, ClientOptionsBuilder> setup = null): base(CreateClientOptions(setup)) 
					{ 
						«FOR consumedService : application.consumedServices»
						«consumedService.aliasOrName» = new «application.name.toFirstUpper».«consumedService.aliasOrName»Proxy(this);
						«ENDFOR»						
					}
				«ENDIF»
				
				«FOR consumedService: application.consumedServices SEPARATOR '\n'»					
					public partial interface I«consumedService.aliasOrName»Proxy«IF consumedService.methods.length > 0»:«ENDIF»
						«FOR consumedMethod : consumedService.methods SEPARATOR ','»
							«consumedService.service.csharpFullName».I«consumedMethod.method.name.toFirstUpper»Proxy
						«ENDFOR»						
					{ }
					
					public sealed partial class «consumedService.aliasOrName»Proxy: I«consumedService.aliasOrName»Proxy {
						
						«IF consumedService.alias === null»
						public static «consumedService.service.csharpFullName».Descriptor Descriptor = «consumedService.service.csharpFullName».DefaultDescriptor;
						«ELSE»
						public static «consumedService.service.csharpFullName».Descriptor Descriptor = «consumedService.service.csharpFullName».CreateDescriptor("«consumedService.alias»");
						«ENDIF»
						
						private readonly IClientCallInvoker _callInvoker;
												
						public «consumedService.service.name.toFirstUpper»Proxy(IClientCallInvoker callInvoker) {
							_callInvoker = callInvoker;
						}						
						
						«FOR consumedMethod : consumedService.methods SEPARATOR '\n'»
							public «consumedMethod.method.genProxySignature("request")» {
								«IF consumedMethod.method.request.isStream»
									return _callInvoker.Call(Descriptor.«consumedMethod.method.name.toFirstUpper»Method);
								«ELSE»
									return _callInvoker.Call(Descriptor.«consumedMethod.method.name.toFirstUpper»Method, request);
								«ENDIF»								
							}
						«ENDFOR»
					}
					
					public I«consumedService.aliasOrName»Proxy «consumedService.aliasOrName» { get; private set; }
				«ENDFOR»
			}
		'''		
	}
	
	def String genImplCallCode(Method method, String varName) {
		if (method.pointToPoint) {
			'''«varName».«method.name.toFirstUpper»(request, context)'''
		} else if (method.serverStreaming) {
			'''«varName».«method.name.toFirstUpper»(request, responseStream, context)'''
		} else if (method.clientStreaming) {
			'''«varName».«method.name.toFirstUpper»(requestStream, context)'''
		} else if (method.bidiStreaming) {			
			'''«varName».«method.name.toFirstUpper»(requestStream, responseStream, context)'''
		}
	}	
	
	def String getAliasOrName(ProvidedService providedService) {
		if (providedService.alias !== null) providedService.alias.toFirstUpper else providedService.service.name.toFirstUpper 
	}
	
	def String getAliasOrName(ConsumedService consumedService) {
		if (consumedService.alias !== null) consumedService.alias.toFirstUpper else consumedService.service.name.toFirstUpper 
	}

	def String gen(Service service) {
		'''
			«accessModifier» sealed partial class «service.name.toFirstUpper» {
				
				public const string Id = "«getFullName(service, qualifiedNameProvider)»";			
				«FOR method : service.methods»
					public const string «method.name.toFirstUpper»MethodId = "«method.name»";
				«ENDFOR»
				
				public static readonly «service.name.toFirstUpper».Descriptor DefaultDescriptor = CreateDescriptor();
				
				public static «service.name.toFirstUpper».Descriptor CreateDescriptor() {
					return new «service.name.toFirstUpper».Descriptor();
				} 
				
				public static «service.name.toFirstUpper».Descriptor CreateDescriptor(string alias) {
					return new «service.name.toFirstUpper».Descriptor(alias);
				}				
			
				«FOR method : service.methods SEPARATOR '\n'»
				public partial interface I«method.name.toFirstUpper»Proxy {
					«genProxySignature(method, "request")»;
				}
				«ENDFOR»
				
				«FOR method : service.methods SEPARATOR '\n'»
				public partial interface I«method.name.toFirstUpper»Impl {
					«genImplSignature(method)»;
				}
				«ENDFOR»
				
				public sealed partial class Descriptor {
				
					«FOR method : service.methods»
					public «method.csharpTypeDeclaration» «method.name.toFirstUpper»Method {get; private set; }
					«ENDFOR»
					
					public Descriptor() {				
						«FOR method : service.methods»
							«method.name.toFirstUpper»Method = Method.«method.type»«method.genericArgs»(Id, «method.name.toFirstUpper»MethodId);
						«ENDFOR»
					}
				
					public Descriptor(string alias) {
						«FOR method : service.methods»
							«method.name.toFirstUpper»Method = Method.«method.type»«method.genericArgs»(Id, alias, «method.name.toFirstUpper»MethodId);
						«ENDFOR»
					}
				}
			}
		'''
	}

	def String genProxySignature(Method method, String requestVarName) {
		if (method.pointToPoint) {
			'''IUnaryMethodCall<«method.response.message.csharpFullName»> «method.name.toFirstUpper»(«method.request.message.csharpFullName» «requestVarName»)'''
		} else if (method.serverStreaming) {
			'''IServerStreamingMethodCall<«method.response.message.csharpFullName»> «method.name.toFirstUpper»(«method.request.message.csharpFullName» «requestVarName»)'''
		} else if (method.clientStreaming) {
			'''IClientStreamingMethodCall<«method.request.message.csharpFullName», «method.response.message.csharpFullName»> «method.name.toFirstUpper»()'''
		} else if (method.bidiStreaming) {
			'''IDuplexStreamingMethodCall<«method.request.message.csharpFullName», «method.response.message.csharpFullName»> «method.name.toFirstUpper»()'''
		}
	}

	def String genImplSignature(Method method) {
		if (method.pointToPoint) {
			'''Task<«method.response.message.csharpFullName»> «method.name.toFirstUpper»(«method.request.message.csharpFullName» request, MethodCallContext context)'''
		} else if (method.serverStreaming) {
			'''Task «method.name.toFirstUpper»(«method.request.message.csharpFullName» request, IWritableChannel<«method.response.message.csharpFullName»> responseStream, MethodCallContext context)'''
		} else if (method.clientStreaming) {
			'''Task<«method.response.message.csharpFullName»> «method.name.toFirstUpper»(IReadableChannel<«method.request.message.csharpFullName»> requestStream, MethodCallContext context)'''
		} else if (method.bidiStreaming) {
			'''Task «method.name.toFirstUpper»(IReadableChannel<«method.request.message.csharpFullName»> requestStream, IWritableChannel<«method.response.message.csharpFullName»> responseStream, MethodCallContext context)'''
		}
	}

	def String genMethodDescriptorStaticDeclaration(Method method) {
		'''public static readonly «method.getCsharpTypeDeclaration» «method.name.toFirstUpper»Method = «genMethodDescriptorDeclaration(method)»;'''
	}

	def String genMethodDescriptorDeclaration(Method method) {
		val serviceName = method.service.getFullName(qualifiedNameProvider);
		val type = method.type
		'''Method.«type»«method.genericArgs»("«serviceName»", "«method.name»")'''
	}

	def String genMethodDescriptorDeclaration(Method method, String aliasVar) {
		val serviceName = method.service.getFullName(qualifiedNameProvider);
		val type = method.type
		'''Method.«type»«method.genericArgs»("«serviceName»", «aliasVar», "«method.name»")'''
	}

	def String getGenericArgs(Method method) {
		val requestName = method.request.message.csharpFullName
		val responseName = method.response.message.csharpFullName
		'''<«requestName», «responseName»>'''
	}

	def String getCsharpTypeDeclaration(Method method) {
		'''«method.type»Method«method.genericArgs»'''
	}

	def static String getType(Method method) {
		var methodType = "Unary"
		if (method.pointToPoint) {
			methodType = "Unary"
		} else if (method.serverStreaming) {
			methodType = "ServerStreaming"
		} else if (method.bidiStreaming) {
			methodType = "DuplexStreaming"
		} else if (method.clientStreaming) {
			methodType = "ClientStreaming"
		}
	}

	def getCsharpNamespace(Resource resource) {
		var ns = "Plexus.Interop.Generated";
		val package = resource.allContents.filter(typeof(Proto)).findFirst[x|true]
		if (package !== null) {					
			ns = qualifiedNameProvider.getFullyQualifiedName(package).skipFirst(1).segments.map[x|x.toFirstUpper].join(".");		
		}
		val option = package.eContents.filter(typeof(Option)).findFirst[o|o.name.equals("csharp_namespace")]
		if (option !== null) {			
			ns = option.value.substring(1, option.value.length - 1)
		}
		if (config.namespace !== null) {
			ns = config.namespace;
		}
		return ns
	}

	def getCsharpFullName(Message obj) {
		return "global::" + getCsharpNamespace(obj.eResource) + "." + obj.name.toFirstUpper
	}    
	
	def getCsharpFullName(Service obj) {
		return "global::" + getCsharpNamespace(obj.eResource) + "." + obj.name.toFirstUpper
	}
}